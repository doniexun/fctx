====
TODO
====

Milestone 1.1 (Cleanup)
=======================

- (P1) Start a CHANGES file.

- (P1) Write a "manual" check list to make sure everything is working
  correctly.  Some tests are impossible to test without running it, and
  requires a manual check.

  - Added a "check.bat" that compiles and executes all the tests in both
    release and debug mode.

- (P1) Write a HACKING file.
  - Include "Basic Idea"
  - Write up a little documentation on the "design" of the framework. A
    HACKING guide.

- (P1) Port "fct_timer" to other operating systems. Use plain ole time()
  until I figure something else out.

- (P1) Test with other compilers
  - gcc?

- (P2) Start up a more involved documentation project.

- (P1) Start up a "SCONS" project, or at least look into it.

- (P1) Implement and document how to "extend" you own logger.

- (P2) Clean up the low-budget memory checks. THe ones that use 

     assert( var != NULL && "out of memory!");

  becaues those aren't with us during a release! We need to be able to
  play well in a test environment that may be stressing the system.

- Move all the SLN and VCPROJ files into a sub-directory called "win32",
  just to seperate the code from the "make files".


MileStone 1.2 (Easier Use)
==========================

- (P1) Expand the "chk" interface (also expand the test_money example to
  use it).

  - fct_eq_*
    These will compare two "fundamental" objects together and return
    true if they 

     - fct_eq_str("a", "b");
     - fct_eq_int(1, 2);
     - fct_eq_dbl(1., 1.2);

     - fct_neq_str("a", "b");
     - fct_neq_int(...
     - fct_neq_dbl(...

     - consider "longs", "void*" (see below), floats, &etc.
       - Maybe build the types out of macros, and create happy versions
         of some of the common ones?

     - (optional) a generic compare...
     
         fct_eq(
             void*, void*, 
             int (*eq)(void*, void*), 
             void (*repr)(char *buffer, size_t len));

         fct_eq(money, money, money_eq, money_repr);

         Could display

             "<money 12 CDN> != <money 14 CDN>"

          where the repr function build the "<money ..>" objects.

- (P1) Quick tests...

     FCT_BGN()
     {
       FCT_QBGN(quick_test)
       {
           /* I just want to run a test! */
       }
       FCT_QEND();
     }
     FCT_END();

   Actually fairly easily to implement as a "quick test suite" each.
   Just need to spend some time testing and verify that the logging
   works.


MileStone 1.3 (Command Line Args)
=================================

- (P2) Better command line parsing. 
  - Need to implement the --help and --version options.
              FCT_TEST_BGN(silly_test_for_null)
              {
                 fct_chk( data != NULL );
              }
              FCT_TEST_END();

- (P1) Run only a specific test suite by name,

      fct.exe --run-suite some_suite

- Add a command line "parser" object, 
  - Parse and keep track of all the command line.
  - Available via the kernel?
  - Track "prefixes" in this same object!

  - Use a table to specify and store results. 

    {[FLAG|STORE], "long-opt", "short-opt", def_buf, def_flag, buffer, flag}

    Either we have flags (on/off) or we are storing arguments. The type
    is defined by the first parameter, the "option" defines the second
    field.  The buffer|flag is a union, which could be either one,
    depending on the type of "option" defined in the table...

    Store default buffer, or flag results in there. 
    
    FLAG_TRUE or FLAG_FALSE or FLAG_STORE.

  - Walk through the argc, argv "chunking" them up based on the table
    specifications above.

  - fft_prsr__is_flag("option")
    fft_prsr__get("option", value, FFT_PRSR_MAX_OPT_LEN);

- Set the logger? Via the command line. 
  --logger-minimal      (-lm)
  --logger-standard     (-ls)
  --logger-verbose      (-lv)    

- Better loggers:
  - minimal ( "." and "!" )
      - on_cndtn_pass
      - on_cndtn_fail
      - on_test_start
      - on_test_end
      - on_test_suite_start
      - on_test_suite_end
      - on_fct_start
      - on_fct_end
  - verbose 
      - on_cndtn_pass
      - on_cndtn_fail
      - on_test_start
      - on_test_end
      - on_test_suite_start
      - on_test_suite_end
      - on_fct_start
      - on_fct_end  

- Write up some rules for creating your own custom logger.


Milestone 1.4 (Major Enhancements)
==================================

- (P3) Make the NList GROWTH rate proportional to its size. The bigger
  the list, the less it has to grow (i.e. the less likely more stuff
  will be added). 

- (P1) Handle assertions -- keep on "trucking".

- (P1) Handle assertions -- optionally check for them.

- (P1) Handle "crashes" -- keep on "trucking".

- (P1) Handle "crashes" -- optionally confirm a crash?? Might be a
  completely useless option.

- (P2) Handle different languages for the built-in loggers.

- Figure out a way to have a test case without a FCT_BGN/END?

    #include "fct.h"

    FCT_VERY_QUICK(test1)
    {
       FCT_CHECK( ok );    // This should fail, with a hint!
    }
    FCT_SUITE_END()
    FCT_VERY_QUICK(test2)
    {
       FCT_CHECK( ok );    // This should fail, with a hint!
    }
    FCT_SUITE_END()

    /* Actually may be impossible. */
